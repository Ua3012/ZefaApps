<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Лабіринт — Three.js (фіксований, рух працює)</title>
<style>
  :root{--ui-bg:rgba(0,0,0,0.35);--ui-fg:#fff}
  html,body{height:100%;margin:0;background:#111;font-family:Arial,Helvetica,sans-serif;user-select:none;-webkit-tap-highlight-color:transparent}
  #container{position:relative;width:100vw;height:100vh;overflow:hidden}
  canvas{display:block; width:100%; height:100%; touch-action:none}
  #ui{position:absolute; z-index:30; right:12px; top:12px; color:var(--ui-fg); background:var(--ui-bg); padding:8px 10px; border-radius:8px;}
  #joy{position:absolute; left:18px; bottom:18px; width:120px; height:120px; border-radius:50%; background:var(--ui-bg); display:flex; align-items:center; justify-content:center; z-index:30}
  #knob{width:56px;height:56px;border-radius:50%;background:rgba(0,200,120,0.9);transform:translate(0,0);touch-action:none}
  #minimap{position:absolute; left:12px; top:12px; width:180px; height:180px; background:rgba(0,0,0,0.22); border-radius:8px; z-index:30; padding:6px; box-sizing:border-box}
  #minimap canvas{width:100%;height:100%;display:block}
  #overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:999; pointer-events:none}
  #overlay .box{pointer-events:auto; background:#111; color:#fff; padding:16px; border-radius:8px; max-width:780px; box-shadow:0 8px 40px rgba(0,0,0,0.7)}
  #reset{position:absolute; right:12px; bottom:18px; z-index:30}
  button{background:transparent;color:var(--ui-fg);border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;cursor:pointer}
</style>
</head>
<body>
<div id="container">
  <div id="minimap"><canvas id="mm" width="180" height="180"></canvas></div>
  <div id="joy"><div id="knob"></div></div>
  <div id="ui">WASD / стрілки — рух<br>Миша/дотик справа — огляд</div>
  <button id="reset">Відновити позицію</button>
  <div id="overlay" style="display:none">
    <div class="box" id="overlayBox"></div>
  </div>
</div>

<script type="module">
// === Overlay для помилок загрузки ===
function showOverlay(html){
  const overlay = document.getElementById('overlay');
  const box = document.getElementById('overlayBox');
  box.innerHTML = html;
  overlay.style.display = 'flex';
}

// === Динамічно підключаємо Three.js ===
async function loadThreeModule(){
  try {
    return await import('./three.module.min.js');
  } catch(errLocal){
    try {
      return await import('https://unpkg.com/three@0.162.0/build/three.module.min.js');
    } catch(errCDN){
      showOverlay(
        `<h3>Не вдалося завантажити Three.js</h3>
         <p>Браузер або середовище (наприклад, Telegram Web App) блокує завантаження модулів з CDN і локального файлу.</p>
         <p>Рішення:</p>
         <ol>
           <li>Скачай файл <code>three.module.min.js</code> версії 0.162.0 з <a href="https://unpkg.com/three@0.162.0/build/three.module.min.js" target="_blank">офіційного джерела</a> та помісти поруч з цим файлом.</li>
           <li>Або скопіюй вміст файлу прямо у <code>./three.module.min.js</code> у твоєму репозиторії.</li>
         </ol>
         <p>Після цього перезавантаж сторінку — гра запуститься локально без додаткових підключень.</p>`
      );
      throw new Error('Three.js module not available');
    }
  }
}
const THREEmod = await loadThreeModule();
const THREE = THREEmod;

// === Three.js сцена, камера, рендерер ===
const container = document.getElementById('container');
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.display = 'block';
container.insertBefore(renderer.domElement, container.firstChild);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x7fbfff);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 5000);

// === Карта лабіринту ===
const map = [
  [1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,0,1,1,1,0,1,1,0,1],
  [1,0,1,0,0,0,1,0,0,1,0,1],
  [1,0,1,1,1,0,1,1,0,1,0,1],
  [1,0,0,0,1,0,0,0,0,1,0,1],
  [1,1,1,0,1,1,1,1,0,1,0,1],
  [1,0,0,0,0,0,0,1,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1]
];
const TILE = 64, HALF = TILE/2;

// === Cвітло ===
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(1,2,1).normalize();
scene.add(dir);
scene.add(new THREE.AmbientLight(0x606060));

// === Стіни ===
const wallMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
const wallGeo = new THREE.BoxGeometry(TILE, TILE, TILE);
for(let z=0; z<map.length; z++){
  for(let x=0; x<map[0].length; x++){
    if(map[z][x] === 1){
      const m = new THREE.Mesh(wallGeo, wallMat);
      m.position.set(x * TILE + HALF, HALF, z * TILE + HALF);
      scene.add(m);
    }
  }
}

// === Підлога ===
const floorGeo = new THREE.PlaneGeometry(map[0].length * TILE, map.length * TILE);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x4b4b4b });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.position.set((map[0].length * TILE)/2, 0, (map.length * TILE)/2);
scene.add(floor);

// === Гравець ===
const startPos = { x: 1.5, z: 1.5, yaw: 0, pitch: 0 };
const player = {
  x: startPos.x * TILE,
  z: startPos.z * TILE,
  y: 32,
  yaw: startPos.yaw,
  pitch: startPos.pitch,
  speed: 150,
  turnSpeed: 0.0025
};
function syncCamera(){
  camera.position.set(player.x, player.y, player.z);
  camera.rotation.x = player.pitch;
  camera.rotation.y = player.yaw;
}
syncCamera();

function isWallAt(px, pz){
  const mx = Math.floor(px / TILE);
  const mz = Math.floor(pz / TILE);
  if(mz < 0 || mz >= map.length || mx < 0 || mx >= map[0].length) return true;
  return map[mz][mx] === 1;
}

// === Керування: клавіатура ===
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// === Керування: джойстик ===
const joy = document.getElementById('joy');
const knob = document.getElementById('knob');
let joyRect = joy.getBoundingClientRect();
window.addEventListener('resize', () => joyRect = joy.getBoundingClientRect());
let moveJoy = { x:0, y:0 };
let knobId = null, knobDragging = false;
function updateKnobCenter(){ joyRect = joy.getBoundingClientRect(); }
function setKnobPos(nx, ny){
  const max = (joyRect.width - knob.offsetWidth)/2;
  const px = nx * max, py = ny * max;
  knob.style.transform = `translate(${px}px, ${py}px)`;
  moveJoy.x = nx; moveJoy.y = -ny;
}
function resetKnob(){ knob.style.transform = 'translate(0,0)'; moveJoy.x = 0; moveJoy.y = 0; }
knob.addEventListener('mousedown', e => { knobDragging = true; updateKnobCenter(); e.preventDefault(); });
window.addEventListener('mouseup', () => { knobDragging = false; resetKnob(); });
window.addEventListener('mousemove', e => {
  if(!knobDragging) return;
  const dx = e.clientX - (joyRect.left + joyRect.width/2);
  const dy = e.clientY - (joyRect.top + joyRect.height/2);
  const max = (joyRect.width - knob.offsetWidth)/2;
  let nx = dx / max, ny = dy / max;
  const mag = Math.hypot(nx, ny); if(mag > 1){ nx/=mag; ny/=mag; }
  setKnobPos(nx, ny);
});
joy.addEventListener('touchstart', e => {
  for(const t of e.changedTouches){ knobId = t.identifier; knobDragging=true; updateKnobCenter();
    const dx = t.clientX - (joyRect.left + joyRect.width/2);
    const dy = t.clientY - (joyRect.top + joyRect.height/2);
    const max = (joyRect.width - knob.offsetWidth)/2;
    let nx = dx / max, ny = dy / max; const mag = Math.hypot(nx,ny); if(mag>1){nx/=mag;ny/=mag;}
    setKnobPos(nx, ny); break;
  } e.preventDefault();
}, { passive:false });
joy.addEventListener('touchmove', e => {
  for(const t of e.changedTouches){ if(t.identifier !== knobId) continue;
    const dx = t.clientX - (joyRect.left + joyRect.width/2);
    const dy = t.clientY - (joyRect.top + joyRect.height/2);
    const max = (joyRect.width - knob.offsetWidth)/2;
    let nx = dx / max, ny = dy / max; const mag = Math.hypot(nx,ny); if(mag>1){nx/=mag;ny/=mag;}
    setKnobPos(nx, ny); break;
  } e.preventDefault();
}, { passive:false });
joy.addEventListener('touchend', e => { for(const t of e.changedTouches){ if(t.identifier===knobId){ knobDragging=false; knobId=null; resetKnob(); } } e.preventDefault(); }, { passive:false });

// === Огляд: миша та touch справа ===
let lastPointerX = null;
renderer.domElement.addEventListener('mouseenter', e => { lastPointerX = e.clientX; });
renderer.domElement.addEventListener('mousemove', e => {
  if(lastPointerX === null){ lastPointerX = e.clientX; return; }
  if (document.pointerLockElement) {
    player.yaw -= e.movementX * player.turnSpeed;
  } else {
    const dx = e.clientX - lastPointerX;
    lastPointerX = e.clientX;
    player.yaw -= dx * player.turnSpeed;
  }
});
renderer.domElement.addEventListener('mouseleave', () => { lastPointerX = null; });

let touchViewId = null, lastTouchX = 0;
renderer.domElement.addEventListener('touchstart', e => {
  for(const t of e.changedTouches){
    if(t.clientX > window.innerWidth * 0.45 && touchViewId === null){
      touchViewId = t.identifier; lastTouchX = t.clientX;
    }
  }
}, { passive:false });
renderer.domElement.addEventListener('touchmove', e => {
  for(const t of e.changedTouches){
    if(t.identifier === touchViewId){
      const dx = t.clientX - lastTouchX; lastTouchX = t.clientX;
      player.yaw -= dx * player.turnSpeed;
    }
  } e.preventDefault();
}, { passive:false });
renderer.domElement.addEventListener('touchend', e => { for(const t of e.changedTouches){ if(t.identifier===touchViewId) touchViewId=null; } }, { passive:false });

// === Основний цикл ===
let prev = performance.now();
function loop(now){
  const dt = (now - prev) / 1000; prev = now;

  let forward = 0, strafe = 0;
  if(keys['w']||keys['arrowup']) forward += 1;
  if(keys['s']||keys['arrowdown']) forward -= 1;
  if(keys['a']||keys['arrowleft']) strafe -= 1;
  if(keys['d']||keys['arrowright']) strafe += 1;
  forward += moveJoy.y; strafe += moveJoy.x;
  const mag = Math.hypot(forward, strafe) || 1;
  forward /= mag; strafe /= mag;

  const angle = player.yaw;
  const vx = (Math.cos(angle) * forward - Math.sin(angle) * strafe) * player.speed * dt;
  const vz = (Math.sin(angle) * forward + Math.cos(angle) * strafe) * player.speed * dt;

  const pad = 18;
  const nx = player.x + vx;
  const nz = player.z + vz;
  if(!isWallAt(nx + pad * Math.sign(vx || 1), player.z)) player.x = nx;
  if(!isWallAt(player.x, nz + pad * Math.sign(vz || 1))) player.z = nz;

  syncCamera();
  renderer.render(scene, camera);
  renderMinimap();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// === Мінікарта ===
const mm = document.getElementById('mm');
const mmCtx = mm.getContext('2d');
function renderMinimap(){
  const W = mm.width, H = mm.height;
  mmCtx.clearRect(0,0,W,H);
  mmCtx.save();
  mmCtx.fillStyle = 'rgba(0,0,0,0.15)';
  mmCtx.fillRect(0,0,W,H);
  const scale = Math.min((W-8) / (map[0].length * TILE), (H-8) / (map.length * TILE));
  const ox = 4, oy = 4;
  for(let z=0; z<map.length; z++){
    for(let x=0; x<map[0].length; x++){
      mmCtx.fillStyle = map[z][x] === 1 ? '#222' : '#ddd';
      mmCtx.fillRect(ox + x * TILE * scale, oy + z * TILE * scale, TILE * scale - 1, TILE * scale - 1);
    }
  }
  const px = ox + player.x * scale;
  const pz = oy + player.z * scale;
  mmCtx.fillStyle = 'lime';
  mmCtx.beginPath(); mmCtx.arc(px, pz, 6, 0, Math.PI*2); mmCtx.fill();
  mmCtx.restore();
}

// === Reset позиції ===
document.getElementById('reset').addEventListener('click', () => {
  player.x = startPos.x * TILE; player.z = startPos.z * TILE; player.yaw = startPos.yaw; player.pitch = startPos.pitch; syncCamera();
});

// === Resize ===
window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  joyRect = joy.getBoundingClientRect();
});

// === Pointer Lock (за бажанням) ===
// renderer.domElement.addEventListener('click', ()=>{ renderer.domElement.requestPointerLock(); });

</script>
</body>
</html>
