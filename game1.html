<!DOCTYPE html>
<html lang='uk'>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width,initial-scale=1.0'>
<title>3D Лабіринт — виправлено</title>
<style>
  html,body { height:100%; margin:0; background:#202020; font-family:Arial, sans-serif; -webkit-tap-highlight-color:transparent; user-select:none; }
  #game { position:relative; width:100vw; height:100vh; overflow:hidden; }
  canvas { display:block; width:100%; height:100%; background:#808080; touch-action:none; cursor: none; }
  /* Джойстик для руху (лівий низ) */
  #joy {
    position:absolute; left:20px; bottom:20px; width:120px; height:120px;
    border-radius:50%; background:rgba(0,0,0,0.25); touch-action:none;
    display:flex; align-items:center; justify-content:center;
  }
  #knob {
    width:56px; height:56px; border-radius:50%;
    background:rgba(0,200,100,0.7); transform:translate(0,0);
    touch-action:none;
  }
  #info {
    position:absolute; right:10px; top:10px; color:#fff; font-size:13px; background:rgba(0,0,0,0.3);
    padding:8px 10px; border-radius:6px;
  }
  #reset {
    position:absolute; right:10px; bottom:20px; padding:8px 10px; border-radius:6px; background:rgba(255,255,255,0.08);
    color:#fff; border:1px solid rgba(255,255,255,0.06); cursor:pointer;
  }
</style>
</head>
<body>
<div id='game'>
  <canvas id='screen'></canvas>

  <div id='joy'>
    <div id='knob'></div>
  </div>

  <div id='info'>
    WASD / стрілки — рух<br>
    Миша або дотик справа — огляд (без натиску)
  </div>

  <button id='reset'>Відновити позицію</button>
</div>

<script>
/* 3D Лабіринт — оновлений
   Камера: реагує на рух миші без натискання (mousemove)
   Мінімап: стрілку напрямку прибрано
*/

const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;

const map = [
  [1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,0,1,1,1,0,1,1,0,1],
  [1,0,1,0,0,0,1,0,0,1,0,1],
  [1,0,1,1,1,0,1,1,0,1,0,1],
  [1,0,0,0,1,0,0,0,0,1,0,1],
  [1,1,1,0,1,1,1,1,0,1,0,1],
  [1,0,0,0,0,0,0,1,0,0,0,1],
  [1,0,1,1,1,1,0,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1]
];
const TILE = 64;

let player = {
  x: 2.5 * TILE,
  y: 2.5 * TILE,
  angle: 0,
  height: 32,
  speed: 150,
  turnSpeed: 3.0
};

const startState = { x: player.x, y: player.y, angle: player.angle };

const FOV = Math.PI / 3;
let numRays = Math.floor(W / 2);
const maxDepth = 1000;

const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  numRays = Math.floor(W / 2);
}
window.addEventListener('resize', resize);

function isWall(px, py){
  const mx = Math.floor(px / TILE);
  const my = Math.floor(py / TILE);
  if(my < 0 || my >= map.length || mx < 0 || mx >= map[0].length) return true;
  return map[my][mx] !== 0;
}

function castRay(rx, ry, angle){
  const dx = Math.cos(angle);
  const dy = Math.sin(angle);
  let mapX = Math.floor(rx / TILE);
  let mapY = Math.floor(ry / TILE);
  let sideDistX, sideDistY;
  const deltaDistX = Math.abs(1 / dx) * TILE;
  const deltaDistY = Math.abs(1 / dy) * TILE;
  let stepX, stepY;
  if(dx < 0){
    stepX = -1;
    sideDistX = (rx - mapX * TILE) * Math.abs(1 / dx);
  } else {
    stepX = 1;
    sideDistX = ((mapX + 1) * TILE - rx) * Math.abs(1 / dx);
  }
  if(dy < 0){
    stepY = -1;
    sideDistY = (ry - mapY * TILE) * Math.abs(1 / dy);
  } else {
    stepY = 1;
    sideDistY = ((mapY + 1) * TILE - ry) * Math.abs(1 / dy);
  }

  let hit = false;
  let side = 0;
  let distance = 0;
  let hitX = 0, hitY = 0;

  for(let i = 0; i < 1000; i++){
    if(sideDistX < sideDistY){
      mapX += stepX;
      distance = sideDistX;
      sideDistX += deltaDistX;
      side = 0;
    } else {
      mapY += stepY;
      distance = sideDistY;
      sideDistY += deltaDistY;
      side = 1;
    }
    if(mapY < 0 || mapY >= map.length || mapX < 0 || mapX >= map[0].length) break;
    if(map[mapY][mapX] === 1){
      hit = true;
      hitX = rx + dx * distance;
      hitY = ry + dy * distance;
      break;
    }
  }

  if(!hit) return { distance: maxDepth, wallX:0, wallY:0, hitVertical:false, mapX:-1, mapY:-1 };
  return { distance: distance, wallX: hitX, wallY: hitY, hitVertical: side === 0, mapX: mapX, mapY: mapY };
}

let lastTime = performance.now();
function frame(now){
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  updatePlayer(dt);
  renderScene();
  requestAnimationFrame(frame);
}

let moveJoy = { x:0, y:0 };
function updatePlayer(dt){
  let forward = 0, strafe = 0;
  if(keys['w'] || keys['arrowup']) forward += 1;
  if(keys['s'] || keys['arrowdown']) forward -= 1;
  if(keys['a'] || keys['arrowleft']) strafe -= 1;
  if(keys['d'] || keys['arrowright']) strafe += 1;
  forward += moveJoy.y;
  strafe += moveJoy.x;
  const mag = Math.hypot(forward, strafe) || 1;
  forward /= mag;
  strafe /= mag;
  const vx = (Math.cos(player.angle) * forward - Math.sin(player.angle) * strafe) * player.speed * dt;
  const vy = (Math.sin(player.angle) * forward + Math.cos(player.angle) * strafe) * player.speed * dt;
  let nx = player.x + vx;
  let ny = player.y + vy;
  const pad = 18;
  if(!isWall(nx + pad * Math.sign(vx), player.y)) player.x = nx;
  if(!isWall(player.x, ny + pad * Math.sign(vy))) player.y = ny;
}

function renderScene(){
  ctx.clearRect(0,0,W,H);
  const horizon = Math.floor(H / 2);
  ctx.fillStyle = '#7fbfff';
  ctx.fillRect(0, 0, W, horizon);
  ctx.fillStyle = '#404040';
  ctx.fillRect(0, horizon, W, H - horizon);
  const rayStep = FOV / numRays;
  const distToProjPlane = (W / 2) / Math.tan(FOV / 2);

  for(let i = 0; i < numRays; i++){
    const rayAngle = player.angle - FOV/2 + i * rayStep;
    const ray = castRay(player.x, player.y, rayAngle);
    const correctedDist = ray.distance * Math.cos(rayAngle - player.angle);
    const wallHeight = (TILE / correctedDist) * distToProjPlane;
    const wallTop = Math.floor(horizon - wallHeight / 2);
    const wallBottom = Math.floor(horizon + wallHeight / 2);
    const shade = Math.max(0.2, 1 - correctedDist / 800);
    const baseColor = ray.hitVertical ? 200 : 160;
    const colorVal = Math.floor(baseColor * shade);
    const col = 'rgb(' + colorVal + ',' + Math.floor(colorVal*0.9) + ',' + Math.floor(colorVal*0.7) + ')';
    const stripW = W / numRays;
    const x = Math.floor(i * stripW);
    ctx.fillStyle = col;
    ctx.fillRect(x, wallTop, Math.ceil(stripW)+1, Math.max(0, wallBottom - wallTop));
  }

  drawMiniMap();
}

function drawMiniMap(){
  const scale = 0.18;
  const mmW = map[0].length * TILE * scale;
  const mmH = map.length * TILE * scale;
  const pad = 10;
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(pad - 4, pad - 4, mmW + 8, mmH + 8);

  for(let y = 0; y < map.length; y++){
    for(let x = 0; x < map[0].length; x++){
      ctx.fillStyle = map[y][x] === 1 ? '#222' : '#ddd';
      ctx.fillRect(pad + x * TILE * scale, pad + y * TILE * scale, TILE * scale - 1, TILE * scale - 1);
    }
  }

  // гравець на міні-карті (без стрілки напрямку)
  ctx.fillStyle = 'lime';
  const px = pad + (player.x / TILE) * TILE * scale;
  const py = pad + (player.y / TILE) * TILE * scale;
  ctx.beginPath();
  ctx.arc(px, py, 6, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// Миша: реагує на рух без натискання
let lastPointerX = null;
let lastPointerY = null;

// при вході на полотно ініціалізуємо останні координати — щоб уникнути великого стрибка
canvas.addEventListener('mouseenter', e => {
  lastPointerX = e.clientX;
  lastPointerY = e.clientY;
});

// Завжди слухаємо рух миші і обертаємо камеру
canvas.addEventListener('mousemove', e => {
  if(lastPointerX === null){ lastPointerX = e.clientX; lastPointerY = e.clientY; return; }
  const dx = e.clientX - lastPointerX;
  lastPointerX = e.clientX;
  player.angle += dx * -0.005 * player.turnSpeed;
});

// Якщо курсор вийшов з полотна — обнуляємо lastPointer, щоб при поверненні не було стрибка
canvas.addEventListener('mouseleave', () => {
  lastPointerX = null;
  lastPointerY = null;
});

// Сенсор: драг праворуч для огляду
let touchIdView = null;
let lastTouchX = 0;

canvas.addEventListener('touchstart', e => {
  for(const t of e.changedTouches){
    if(t.clientX > window.innerWidth * 0.4 && touchIdView === null){
      touchIdView = t.identifier;
      lastTouchX = t.clientX;
    }
  }
}, { passive:false });

canvas.addEventListener('touchmove', e => {
  for(const t of e.changedTouches){
    if(t.identifier === touchIdView){
      const dx = t.clientX - lastTouchX;
      lastTouchX = t.clientX;
      player.angle += dx * -0.005 * player.turnSpeed;
    }
  }
  e.preventDefault();
}, { passive:false });

canvas.addEventListener('touchend', e => {
  for(const t of e.changedTouches){
    if(t.identifier === touchIdView) touchIdView = null;
  }
}, { passive:false });

// Джойстик
const joy = document.getElementById('joy');
const knob = document.getElementById('knob');
let joyRect = joy.getBoundingClientRect();
window.addEventListener('resize', () => joyRect = joy.getBoundingClientRect());

let knobDragging = false;
let knobId = null;
let knobCenter = { x:0, y:0 };
function updateKnobCenter(){ joyRect = joy.getBoundingClientRect(); knobCenter.x = joyRect.left + joyRect.width/2; knobCenter.y = joyRect.top + joyRect.height/2; }
updateKnobCenter();

function setKnobPos(normX, normY){
  const max = (joyRect.width - knob.offsetWidth) / 2;
  const px = normX * max;
  const py = normY * max;
  knob.style.transform = 'translate(' + px + 'px,' + py + 'px)';
  moveJoy.x = normX;
  moveJoy.y = -normY;
}
function resetKnob(){
  knob.style.transform = 'translate(0,0)';
  moveJoy.x = 0; moveJoy.y = 0;
}

knob.addEventListener('mousedown', e => {
  knobDragging = true;
  updateKnobCenter();
  e.preventDefault();
});
window.addEventListener('mouseup', e => { knobDragging = false; resetKnob(); });

window.addEventListener('mousemove', e => {
  if(!knobDragging) return;
  const dx = e.clientX - knobCenter.x;
  const dy = e.clientY - knobCenter.y;
  const max = (joyRect.width - knob.offsetWidth) / 2;
  let nx = dx / max; let ny = dy / max;
  const mag = Math.hypot(nx, ny);
  if(mag > 1){ nx /= mag; ny /= mag; }
  setKnobPos(nx, ny);
});

joy.addEventListener('touchstart', e => {
  for(const t of e.changedTouches){
    knobId = t.identifier;
    knobDragging = true;
    updateKnobCenter();
    const dx = t.clientX - knobCenter.x;
    const dy = t.clientY - knobCenter.y;
    const max = (joyRect.width - knob.offsetWidth) / 2;
    let nx = dx / max; let ny = dy / max;
    const mag = Math.hypot(nx, ny);
    if(mag > 1){ nx /= mag; ny /= mag; }
    setKnobPos(nx, ny);
    break;
  }
  e.preventDefault();
}, { passive:false });

joy.addEventListener('touchmove', e => {
  for(const t of e.changedTouches){
    if(t.identifier !== knobId) continue;
    const dx = t.clientX - knobCenter.x;
    const dy = t.clientY - knobCenter.y;
    const max = (joyRect.width - knob.offsetWidth) / 2;
    let nx = dx / max; let ny = dy / max;
    const mag = Math.hypot(nx, ny);
    if(mag > 1){ nx /= mag; ny /= mag; }
    setKnobPos(nx, ny);
    break;
  }
  e.preventDefault();
}, { passive:false });

joy.addEventListener('touchend', e => {
  for(const t of e.changedTouches){
    if(t.identifier === knobId){
      knobDragging = false;
      knobId = null;
      resetKnob();
    }
  }
  e.preventDefault();
}, { passive:false });

document.getElementById('reset').addEventListener('click', () => {
  player.x = startState.x; player.y = startState.y; player.angle = startState.angle;
});

// Старт
requestAnimationFrame(frame);
</script>
</body>
</html>
