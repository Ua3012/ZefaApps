<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZefaCraft</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls { position: absolute; bottom: 20px; left: 20px; z-index: 10; }
        button { padding: 10px; margin: 5px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls" style="display: none;">
        <button id="forward">Forward</button>
        <button id="left">Left</button>
        <button id="back">Back</button>
        <button id="right">Right</button>
        <button id="jump">Jump</button>
    </div>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Detect if mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 0, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Controls
        let controls;
        if (!isMobile) {
            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            document.body.addEventListener('click', () => controls.lock());
        } else {
            // For mobile, show buttons
            document.getElementById('controls').style.display = 'block';
            // Use OrbitControls for look, but for FPS, custom
            // For simplicity, use touch for look, buttons for move
        }

        // Block types
        const blockTypes = {
            grass: { color: 0x228B22 }, // Forest green
            stone: { color: 0x808080 }, // Gray
            wood: { color: 0x8B4513 }, // Saddle brown
            leaves: { color: 0x006400 }, // Dark green
            water: { color: 0x0000FF, transparent: true, opacity: 0.5 },
            red: { color: 0xFF0000 },
            green: { color: 0x00FF00 },
            blue: { color: 0x0000FF },
            yellow: { color: 0xFFFF00 },
            cyan: { color: 0x00FFFF },
            magenta: { color: 0xFF00FF },
            black: { color: 0x000000 },
            white: { color: 0xFFFFFF },
            orange: { color: 0xFFA500 },
            purple: { color: 0x800080 },
            brown: { color: 0xA52A2A },
            pink: { color: 0xFFC0CB },
            lime: { color: 0x32CD32 },
            gray: { color: 0x808080 },
            lightgray: { color: 0xD3D3D3 },
            darkgray: { color: 0xA9A9A9 },
            zefa: { map: 'zefablock.png' } // Assume texture in same directory
        };

        // World data
        let blocks = {};
        const blockSize = 1;

        // Load world from localStorage
        function loadWorld() {
            const saved = localStorage.getItem('zefaCraftWorld');
            if (saved) {
                blocks = JSON.parse(saved);
                Object.keys(blocks).forEach(key => {
                    const [x, y, z] = key.split(',').map(Number);
                    createBlock(x, y, z, blocks[key]);
                });
            } else {
                // Generate small grass platform
                for (let x = -5; x <= 5; x++) {
                    for (let z = -5; z <= 5; z++) {
                        addBlock(x, 0, z, 'grass');
                    }
                }
            }
        }

        // Save world
        function saveWorld() {
            localStorage.setItem('zefaCraftWorld', JSON.stringify(blocks));
        }

        // Create block mesh
        const blockMeshes = new Map();
        function createBlock(x, y, z, type) {
            const props = blockTypes[type] || { color: 0xFFFFFF };
            let material;
            if (props.map) {
                const texture = new THREE.TextureLoader().load(props.map);
                material = new THREE.MeshLambertMaterial({ map: texture });
            } else {
                material = new THREE.MeshLambertMaterial({
                    color: props.color,
                    transparent: !!props.transparent,
                    opacity: props.opacity || 1
                });
            }
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x * blockSize + blockSize/2, y * blockSize + blockSize/2, z * blockSize + blockSize/2);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            blockMeshes.set(`${x},${y},${z}`, mesh);
        }

        // Add block
        function addBlock(x, y, z, type = 'stone') { // Default to stone for placement
            const key = `${x},${y},${z}`;
            if (!blocks[key]) {
                blocks[key] = type;
                createBlock(x, y, z, type);
                saveWorld();
            }
        }

        // Remove block
        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if (blocks[key]) {
                const mesh = blockMeshes.get(key);
                if (mesh) {
                    scene.remove(mesh);
                    blockMeshes.delete(key);
                }
                delete blocks[key];
                saveWorld();
            }
        }

        // Player
        const player = {
            position: new THREE.Vector3(0, 5, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            height: 1.8,
            width: 0.6,
            speed: 0.1,
            jumpHeight: 0.3,
            gravity: -0.01,
            onGround: false
        };

        camera.position.copy(player.position);
        camera.position.y += player.height - 0.5; // Eye level

        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // For click

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Mouse click for break/place
        document.addEventListener('mousedown', e => {
            if (!controls.isLocked && !isMobile) return;
            mouse.x = 0; mouse.y = 0; // Center for ray
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (e.button === 0) { // Left click remove
                    const pos = intersect.point.clone().sub(intersect.face.normal.multiplyScalar(0.5)).floor();
                    removeBlock(pos.x, pos.y, pos.z);
                } else if (e.button === 2) { // Right click place
                    const pos = intersect.point.clone().add(intersect.face.normal.multiplyScalar(0.5)).floor();
                    addBlock(pos.x, pos.y, pos.z, 'stone'); // Change to selected block
                }
            }
        });

        // Mobile buttons
        if (isMobile) {
            const forwardBtn = document.getElementById('forward');
            const leftBtn = document.getElementById('left');
            const backBtn = document.getElementById('back');
            const rightBtn = document.getElementById('right');
            const jumpBtn = document.getElementById('jump');

            // Touch events for buttons
            forwardBtn.addEventListener('touchstart', () => keys['w'] = true);
            forwardBtn.addEventListener('touchend', () => keys['w'] = false);
            leftBtn.addEventListener('touchstart', () => keys['a'] = true);
            leftBtn.addEventListener('touchend', () => keys['a'] = false);
            backBtn.addEventListener('touchstart', () => keys['s'] = true);
            backBtn.addEventListener('touchend', () => keys['s'] = false);
            rightBtn.addEventListener('touchstart', () => keys['d'] = true);
            rightBtn.addEventListener('touchend', () => keys['d'] = false);
            jumpBtn.addEventListener('touchstart', () => {
                if (player.onGround) player.velocity.y = player.jumpHeight;
            });

            // Touch for look
            let touchStartX = 0, touchStartY = 0;
            document.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });
            document.addEventListener('touchmove', e => {
                const deltaX = (e.touches[0].clientX - touchStartX) * 0.002;
                const deltaY = (e.touches[0].clientY - touchStartY) * 0.002;
                camera.rotation.y -= deltaX;
                camera.rotation.x -= deltaY;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            // Mobile place/break: tap for break, long press for place?
            // For simplicity, use double tap for place
            let tapCount = 0;
            document.addEventListener('touchend', () => {
                tapCount++;
                setTimeout(() => tapCount = 0, 300);
                mouse.x = 0; mouse.y = 0;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    if (tapCount === 1) {
                        const pos = intersect.point.clone().sub(intersect.face.normal.multiplyScalar(0.5)).floor();
                        removeBlock(pos.x, pos.y, pos.z);
                    } else if (tapCount === 2) {
                        const pos = intersect.point.clone().add(intersect.face.normal.multiplyScalar(0.5)).floor();
                        addBlock(pos.x, pos.y, pos.z, 'stone');
                    }
                }
            });
        }

        // Collision check
        function isColliding(newPos) {
            const corners = [
                new THREE.Vector3(-player.width/2, 0, -player.width/2),
                new THREE.Vector3(player.width/2, 0, -player.width/2),
                new THREE.Vector3(-player.width/2, 0, player.width/2),
                new THREE.Vector3(player.width/2, 0, player.width/2)
            ];
            for (let yOffset = 0; yOffset <= player.height; yOffset += blockSize) {
                for (const corner of corners) {
                    const checkPos = newPos.clone().add(corner).add(new THREE.Vector3(0, yOffset, 0));
                    const blockX = Math.floor(checkPos.x / blockSize);
                    const blockY = Math.floor(checkPos.y / blockSize);
                    const blockZ = Math.floor(checkPos.z / blockSize);
                    if (blocks[`${blockX},${blockY},${blockZ}`]) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Animate loop
        function animate() {
            requestAnimationFrame(animate);

            // Movement
            const direction = new THREE.Vector3();
            const front = new THREE.Vector3();
            camera.getWorldDirection(front);
            front.y = 0;
            front.normalize();
            const right = new THREE.Vector3().crossVectors(front, new THREE.Vector3(0,1,0)).normalize();

            if (keys['w']) direction.add(front);
            if (keys['s']) direction.sub(front);
            if (keys['a']) direction.sub(right);
            if (keys['d']) direction.add(right);

            if (direction.length() > 0) {
                direction.normalize().multiplyScalar(player.speed);
                const newPosX = player.position.clone().add(new THREE.Vector3(direction.x, 0, 0));
                if (!isColliding(newPosX)) player.position.x += direction.x;
                const newPosZ = player.position.clone().add(new THREE.Vector3(0, 0, direction.z));
                if (!isColliding(newPosZ)) player.position.z += direction.z;
            }

            // Gravity and jump
            player.velocity.y += player.gravity;
            const newPosY = player.position.clone().add(new THREE.Vector3(0, player.velocity.y, 0));
            if (!isColliding(newPosY)) {
                player.position.y += player.velocity.y;
                player.onGround = false;
            } else {
                player.velocity.y = 0;
                player.onGround = true;
                if (keys[' ']) player.velocity.y = player.jumpHeight;
            }

            // Respawn if fall into void
            if (player.position.y < -10) {
                player.position.set(0, 5, 0);
                player.velocity.set(0, 0, 0);
            }

            // Update camera
            camera.position.copy(player.position);
            camera.position.y += player.height - 0.5;

            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        loadWorld();
        animate();
    </script>
</body>
</html>
